# Стандарт файла абстрактного синтаксического дерева
## Базовые сведения
Дерево сохраняется в файл в **текстовом** формате. Для сохранения каждого из узлов дерева используется запись вида:

```
( nodeType nodeContent leftChild rightChild )
```

Если `leftChild` или `rightChild` - непустое поддерево, то его запись аналогична представленной выше. Если же потомка у узла нет, то ставится символ подчеркивания, отделенный пробелами с двух сторон.

> [!IMPORTANT]
> Каждый из элементов записи дерева должен быть отделен от соседних **одним** пробелом. Пробела в начале быть **не должно**.

> [!IMPORTANT]
> В случае, если узел не хранит никаких данных, помимо своего типа, его формат становится `( nodeType leftChild rightChild ) `

### Пример дерева
```
( 1 31 ( 2 71 _ ( 3 18 _ _ ) ) _ )
```
Данная запись соответствует дереву на картинке ниже:

~Исправить пример и вставить картинку~

## Таблицы имен

Таблицы имен должны быть сохранены в **отдельный** файл в **текстовом** формате. В дальнейшем при описании действий с таблицами будут использоваться следующие обозначения:

- Общая таблица имен - список, включающий в себя все идентификаторы, используемые в представляемом синтаксическом дереве. Каждому из идентификаторов должен быть присвоен номер (начиная с 0).
- Локальная таблица имен - структура данных, содержащая индексы идентификаторов, входящих в описываемую область видимости (scope), в общей таблице имен и их типы. Каждая локальная таблица имеет индекс в списке таблиц и число (`id`), представляющее из себя индекс идентификатора функции, описываемой текущей таблицей (для области видимости функции). В будующем планируется добавить возможность добавления scope'ов, соответствующих циклам и условным операторам.

> [!IMPORTANT]
> Глобальная область видимости в данной терминологии также описывается **локальной** таблицей имен. При этом индес данной таблицы в списке всегда должен быть равен 0, а eё `id` = -1

## Формат файла таблиц имен

Первой в файле описывается общая таблица имен. На отдельной строке в файле должно располагаться количество идентификаторов в общей таблице `n`, а затем `n` строк, каждая из которых содержит строковое представление идентификатора. Индексы идентификаторов присваиваются по порядку их следования в файле (начиная с 0). Идентификатор может состоять из английских, кириллических, цифровых, специальных и пробельных символов (кроме `\n`)

После предыдущей записи на отдельной строке должено находиться число `m`, обозначающее количество локальных таблиц имен. Затем `m` описаний таблиц, каждое из которых начинается с размера таблицы `k` и ее `id`, записанных через пробел, а следом содержит `k` строк, на каждой из которых должны находиться два числа (через пробел): индекс идентификатора в общей таблице и его тип (`1 - имя переменной, 2 - имя функции, 4 - имя типа данных`). Каждый из индексов не может встречаться более одного раза в любой таблице.

> [!IMPORTANT]
> Допустимо произвольное количество символов новой строки в тех местах, где выше обозначен один такой символ

### Пример таблицы
~~~ C++
double main()
{
    double first  = 0;
    double second = 4;
    double result = Func(first, second);

    return result;
}

double Func(double first, double second)
{
    double sum = first + second;
    return sum;
}
~~~

```
6
main
first
second
result
Func
sum

3

2 -1
0 2
4 2

3 0
1 1
2 1
3 1

3 4
1 1
2 1
5 1
```

## Типы узлов
Первым параметром в каждом из узлов является число, отвечающее за его тип. Список типов и их содержимого представлен в таблице:

| Номер типа | Тип узла             | Содержание узла                                                                  |
|------------|----------------------|----------------------------------------------------------------------------------|
| 1          | `Constant`           | Число в виде десятичной дроби                                                    |
| 2          | `Identifier`         | Индекс идентификатора в общей таблице имен                                       |
| 3          | `Keyword`            | Номер ключевого слова                                                            |
| 4          | `FunctionDefinition` | Индекс идентификатора функции, задаваемой данным узлом                           |
| 5          | `Parameters`         | Нет хранимой величины                                                            |
| 6          | `VarDeclaration`     | Идентификатор создаваемой переменной                                             |
| 7          | `Call`               | Нет хранимой величины                                                            |

Рассмотрим подробнее каждый из типов узлов:

### Constant
Данный тип задает константу времени компиляции, в программе выглядящую, как `1.543` или `-5.67`. Не может иметь потомков и всегда является листом дерева.

Пример:
```
( 1 -1.543 _ _ )
```

### Identifier
Задает идентификатор переменной или функции и является числом, определяюшим положение идентификатора в общей таблице имен. Также, как и константа не может иметь потомков и является листом дерева.

Пример:
```
( 2 <номер идентификатора> _ _ )
```

### Keyword
Узел данного типа является ключевым словом, таким как операторы `return`, `if` или имя типа `Number`. Список всех ключевых слов, реализация которых предусмотрена стандартом представлен ниже. Ключевое слово задается его индексом.

Пример:

```c++
-7 + foo
```

```
( 3 24 ( 1 -7 _ _ ) ( 2 <номер идентификатора foo> _ _ ) )
```

### FunctionDefinition
Задает объявление новой функции и содержит ее идентификатор. В левой ветке содержит тип возвращаемого значения функции, а в правой ноду типа `Parameters`

Пример:

```c++
double Foo() {}
```

```
( 4 <номер идентификатора Foo> ( 3 51 _ _ ) ( 5 _ <тело функции> ) )
```

### Parameters
Данный узел не содержит в себе никаких данных, за исключением типа. В левой ветке узла находится список параметров объявляемой функции, а в правой - тело функции. Параметры в списке разделяются оператором перечисления (см. ниже). При этом, если параметров у функции несколько, то в правом поддереве оператора перечисления должен находиться параметр, а в левом еще один оператор перечисления. Каждый из параметров является узлом типа `VarDeclaration` (см. ниже).

> [!IMPORTANT]
> Важно, что тело функции должно начинаться с оператора последовательного исполнения

Пример:

```c++
double Foo(double a, double b) {}
```
```
(4 <номер идентификатора Foo> ( 3 51 _ _ ) (5 ( 3 42 ( 3 42 <параметр> ) <параметр> ) <тело функции> ) )
```

### VarDeclaration

Обозначает создание новой переменной (в текущей области видимости). Содержит имя новой переменной. Левый потомок - тип новой переменной, правый потомок - идентификатор переменной, либо выражение ее инициализации (выражение присваивания).

Пример 1:

```c++
double foo;
```

```
( 6 <номер идентификатора переменной> ( 3 51 _ _ ) ( 2 <номер идентификатора переменной> _ _ ) )
```

Пример 2:

```c++
double bar = 5;
```

```
( 6 <номер идентификатора переменной> ( 3 51 _ _ ) ( 3 13 ( 1 5 _ _ ) (2 <номер идентификатора переменной> _ _ ) ) )
```

### Call

Задает вызов функции. Не содержит в себе никаких данных, кроме типа. В левой ветке содержит список параметров функции, а в правой ее идентификатор. Список параметров конструируется также, как и в случае с нодой `Parameters` (см. выше), однако каждый из параметров является произвольным арифметическим выражением, а не узлом типа `VarDeclaration`.

Пример:

```c++
Foo(1, 2);

```

```
( 7 ( 3 42 ( ( 3 42 _ ( 1 2 _ _ ) ) ( 1 1 _ _ ) ) ) ( 2 <номер идентификатора функции> ) )
```

## Список ключевых слов

|Номер|Ключевое слово|Описание|
|-----|--------------|--------|
|11|if       |Условный оператор|
|12|while    |Оператор цикла|
|13|=        |Оператор присваивания|
|21|sin      |Синус |
|22|cos      |Косинус|
|23|floor    |Округление вниз|
|24|+        |Сложение|
|25|-        |Вычитание|
|26|*        |Умножение|
|27|/        |Деление|
|28|diff     |Оператор дифференцирования|
|29|sqrt     |Квадратный корень|
|31|==       |Равенство|
|32|<        |Меньше|
|33|>        |Больше|
|34|<=       |Меньше или равно|
|35|>=       |Больше или равно|
|36|!=       |Не равно|
|37|&&       |Логическое И|
|38|\|\|     |Логическое ИЛИ|
|39|!        |Отрицание|
|41|;        |Оператор последовательного исполнения|
|42|,        |Оператор перечисления|
|51|number   |Число с плавающей точкой|
|61|in       |Оператор ввода|
|62|out      |Оператор вывода|
|71|return   |Оператор возврата|
|72|break    |Оператор выхода из цикла|
|73|continue |Оператор перехода на следующую итерацию|
|74|abort    |Оператор завершения программы

## Оператор посдеовательного исполнения

Отделяет между собой ноды c функциями, строками(операторами/операциями). Пример такого дерева:
```
( 3 41 ( 3 13 ( 1 5 _ _ ) ( 2 48 _ _ ) ) ( 3 41 ( ... ) ( 3 41 ( ... ) ( .. ) ) ) )
```

## Арифметические выражения

Арифметические операторы делятся на __унарные__ и __бинарные__.

К __унарным операторам__ относятся:
|Оператор| Что обозначает |
|:--:|:--:|
|cos|  Взятие косинуса от операнда|
|sin | Взятие синуса от операнда|
|sqrt | Взятие арифметического квадратного корня от операнда|
|floor | Округление операнда вниз|

У каждого из них операнд находится в правом поддереве.

~Димон вставь тут графический пример дерева~

К __бинарным операторам__ относятся:
|Оператор| Что обозначает |
|:--:|:--:|
|+| Сложение левого операнда правым |
|*| Произведение левого операнда на правый |
|-| Вычитание правого операнда из левого |
|/| Деление левого операнда на правый |

У узлов соответствующих этим операторам
__левый операнд__ находится в __левом поддереве__,
__правый операнд__ находится в __правом поддереве__.

### Оператор дифференцирования

Во время оптимизации узел соответствующий этому оператору заменяется на
выражение, являющееся производной от его операнда.

~Дима, нужны примеры до дифференцирования и после~

## Выражения присваивания

Присваивает переменной заданное значение.

Пример:
``` c++

a = 10;

```

Для вышеописанного кода будет сгенерировано следующее поддерево:

```

( 3 13 ( 1 10 _ _ ) ( 2 1 <1 - номер идентификатора переменной 'a'> _ _ ) )

```

Переменной также может присваиваться значение некого арифметического выражения.

Тогда дерево будет выглядеть следующим образом:

```

( 3 13 ( <выражение> ) ( 2 1 <1 - номер идентификатора переменной 'a'> _ _ ) )

```

## Условные и циклические операторы

~Написать~

## Оператор возврата значения

Заканчивает исполнение функции, возвращая значение, задаваемое правым поддеревом.

> [!IMPORTANT]
> Для корректной кодогенерации необходимо, чтобы каждая ветвь исполнения функции заканчивалась оператором `return`

Пример:
``` c++
return 5;
```
Код приведенный выше будет оттранслирован в следующее поддерево:

```
( 3 71 _ ( 1 5 _ _ ) )
```

