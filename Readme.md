# Стандарт файла абстрактного синтаксического дерева
## Базовые сведения
Дерево сохраняется в файл в **текстовом** формате. Для сохранения каждого из узлов дерева используется запись вида:

```
( nodeType nodeContent leftChild rightChild )
```

Если `leftChild` или `rightChild` - непустое поддерево, то его запись аналогична представленной выше. Если же потомка у узла нет, то ставится символ подчеркивания, отделенный пробелами с двух сторон.

> [!IMPORTANT]
> Каждый из элементов записи дерева должен быть отделен от соседних **одним** пробелом. Пробела в начале быть **не должно**.

> [!IMPORTANT]
> В случае, если узел не хранит никаких данных, помимо своего типа, его формат становится `( nodeType leftChild rightChild ) `

### Пример дерева
```
( 1 31 ( 2 71 _ ( 3 18 _ _ ) ) _ )
```
Данная запись соответствует дереву на картинке ниже:

~Исправить пример и вставить картинку~

## Таблицы имен

Таблицы имен должны быть сохранены в **отдельный** файл в **текстовом** формате. В дальнейшем при описании действий с таблицами будут использоваться следующие обозначения: 

- Общая таблица имен - список, включающий в себя все идентификаторы, используемые в представляемом синтаксическом дереве. Каждому из идентификаторов должен быть присвоен номер (начиная с 0).
- Локальная таблица имен - структура данных, содержащая индексы идентификаторов, входящих в описываемую область видимости (scope), в общей таблице имен и их типы. Каждая локальная таблица имеет индекс в списке таблиц и число (`id`), представляющее из себя индекс идентификатора функции, описываемой текущей таблицей (для области видимости функции). В будующем планируется добавить возможность добавления scope'ов, соответствующих циклам и условным операторам. 

> [!IMPORTANT]
> Глобальная область видимости в данной терминологии также описывается **локальной** таблицей имен. При этом индес данной таблицы в списке всегда должен быть равен 0, а eё `id` = -1

## Формат файла таблиц имен

Первой в файле описывается общая таблица имен. На отдельной строке в файле должно располагаться количество идентификаторов в общей таблице `n`, а затем `n` строк, каждая из которых содержит строковое представление идентификатора. Индексы идентификаторов присваиваются по порядку их следования в файле (начиная с 0). Идентификатор может состоять из английских, кириллических, цифровых, специальных и пробельных символов (кроме `\n`)

После предыдущей записи на отдельной строке должено находиться число `m`, обозначающее количество локальных таблиц имен. Затем `m` описаний таблиц, каждое из которых начинается с размера таблицы `k` и ее `id`, записанных через пробел, а следом содержит `k` строк, на каждой из которых должны находиться два числа (через пробел): индекс идентификатора в общей таблице и его тип (`1 - имя переменной, 2 - имя функции, 4 - имя типа данных`). Каждый из индексов не может встречаться более одного раза в любой таблице.

> [!IMPORTANT]
> Допустимо произвольное количество символов новой строки в тех местах, где выше обозначен один такой символ

### Пример таблицы
~~~ C++
int main()
{
    int first = 0;
    int second = 4;
    int result = Func(first, second);
    return result;
}
   
int Func(int first, int second)
{
    int sum = first + second;
    return sum;
}
~~~

```
6
main
first
second
result
Func
sum

3

2 -1
0 2
4 2

3 0
1 1
2 1
3 1

3 4
1 1
2 1
5 1
```

## Типы узлов
Первым параметром в каждом из узлов является число, отвечающее за его тип. Список типов и их содержимого представлен в таблице:

| Номер типа | Тип узла             | Содержание узла                                                                  |
|------------|----------------------|----------------------------------------------------------------------------------|
| 1          | `Constant`           | Число в виде десятичной дроби                                                    |
| 2          | `Identifier`         | Индекс идентификатора в общей таблице имен                                       |
| 3          | `Keyword`            | Номер ключевого слова                                                            |
| 4          | `FunctionDefinition` | Индекс идентификатора функции, задаваемой данным узлом                           |
| 5          | `Parameters`         | Нет хранимой величины                                                            |
| 6          | `VarDeclaration`     | Идентификатор создаваемой переменной                                             |
| 7          | `Call`               | Нет хранимой величины                                                            |

Рассмотрим подробнее каждый из типов узлов:

### Constant
Данный тип задает константу времени компиляции, в программе выглядящую, как `1.543` или `-5.67`. Не может иметь потомков и всегда является листом дерева.

Пример:
```
( 1 -1.543 _ _ )
```

### Identifier
Задает идентификатор переменной (или функции) и является числом, определяюшим положение идентификатора в общей таблице имен. Также, как и константа не может иметь потомков и является листом дерева.

Пример:
```
( 2 27 _ _ )
```

### Keyword
Узел данного типа является ключевым словом, таким как операторы `return`, `if` или имя типа `Number`. Список всех ключевых слов, реализация которых предусмотрена стандартом представлен ниже. Ключевое слово задается его индексом.

Пример:

```
( 3 24 ( 1 -7 _ _ ) ( 2 44 _ _ ) )
```

### FunctionDefinition
Задает объявление новой функции и содержит ее идентификатор. В левой ветке содержит тип возвращаемого значения функции, а в правой ноду типа `Parameters`

Пример:
```
( 4 42 ( 3 51 _ _ ) ( 5 ... ) )
```

### Parameters
Данный узел не содержит в себе никаких данных, за исключением типа. В левой ветке узла находится список параметров объявляемой функции, а в правой - тело функции.

> [!IMPORTANT]
> Важно, что тело функции должно начинаться с оператора последовательного исполнения


Пример:

~Написать пример~

### VarDeclaration

Обозначает создание новой переменной (в текущей области видимости). Содержит имя новой переменной. Левый потомок - тип новой переменной, правый потомок - идентификатор переменной, либо выражение ее инициализации (выражение присваивания).

Пример:

```
( 6 37 ( 3 51 _ _ ) ( 2 37 _ _ ) )
```

### Call

Задает вызов функции. Не содержит в себе никаких данных, кроме типа. В левой ветке содержит список параметров функции, а в правой ее идентификатор.

Пример:
```
( 7 ( ... ) ( 2 69 ) )
```

## Список ключевых слов

|Номер|Ключевое слово|Описание|
|-----|--------------|--------|
|11|if       |Условный оператор|
|12|while    |Оператор цикла|
|13|=        |Оператор присваивания|
|21|sin      |Синус |
|22|cos      |Косинус|
|23|floor    |Округление вниз|
|24|+        |Сложение|
|25|-        |Вычитание|
|26|*        |Умножение|
|27|/        |Деление|
|28|diff     |Оператор дифференцирования|
|29|sqrt     |Квадратный корень|
|31|==       |Равенство|
|32|<        |Меньше|
|33|>        |Больше|
|34|<=       |Меньше или равно|
|35|>=       |Больше или равно|
|36|!=       |Не равно|
|37|&&       |Логическое И|
|38|\|\|     |Логическое ИЛИ|
|39|!        |Отрицание|
|41|;        |Оператор последовательного исполнения|
|42|,        |Оператор перечисления|
|51|number   |Число с плавающей точкой|
|61|in       |Оператор ввода|
|62|out      |Оператор вывода|
|71|return   |Оператор возврата|
|72|break    |Оператор выхода из цикла|
|73|continue |Оператор перехода на следующую итерацию|
|74|abort    |Оператор завершения программы

## Оператор посдеовательного исполнения

Отделяет между собой ноды c функциями, строками(операторами/операциями). Пример такого дерева:
```
( 3 41 ( 3 13 ( 1 5 _ _ ) ( 2 48 _ _ ) ) ( 3 41 ( ... ) ( 3 41 ( ... ) ( .. ) ) ) )
```

## Арифметические выражения

~Написать~

## Выражения присваивания

~Написать~

## Условные и циклические операторы

~Написать~

## Задание параметров функции

~Написать~

## Оператор возврата значения

~Написать~
